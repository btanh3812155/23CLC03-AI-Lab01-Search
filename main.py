from collections import deque
import heapq
import time
import tracemalloc
from map_util import generate_random_map, delete_map


# MAP PARSING

def parse_map(file_path):
    '''
    Parses a city map from a file.
    Map will be generated by an util function
    The first line should contain two integers for width and height.
    Each subsequent line should contain space-separated values:
    - 'S' for start (cost 0.0)
    - 'G' for goal (cost 0.0)
    - 'N' for wall (None)
    - Numeric values for costs (float)
    Raises ValueError for invalid formats.
    Returns:
    - city_map: 2D list of costs (floats or None)
    - starts: List of start positions (tuples)
    - goals: List of goal positions (tuples)
    '''
    with open(file_path, 'r') as f: # Open file
        lines = [line.strip() for line in f if line.strip()]
    
    try: # Read dimensions
        cols, rows = map(int, lines[0].split())
    except Exception:
        raise ValueError("First line must contain two ints for width & height")

    if len(lines) - 1 != rows:
        raise ValueError(f"Expected {rows} rows but found {len(lines) - 1}")

    city_map = []
    starts = []
    goals = []

    for i in range(1, rows + 1): # Read rows
        row_data = lines[i].split()
        if len(row_data) != cols:
            raise ValueError(f"Row {i} has incorrect number of columns")
        
        row = []
        for j, val in enumerate(row_data):
            if val.upper() == 'S': # Start
                starts.append((i - 1, j))
                row.append(0.0)
            elif val.upper() == 'G': # goal
                goals.append((i - 1, j))
                row.append(0.0)
            elif val.upper() == 'N': # Wall
                row.append(None)
            else:
                try:
                    cost = float(val)
                    row.append(cost)
                except ValueError:
                    raise ValueError(f"Invalid cell value at ({i-1}, {j}): {val}")
        city_map.append(row)

    if not starts or not goals:
        raise ValueError("Map must have at least one start (S) and one goal (G).")

    return city_map, starts, goals


def get_neighbors(pos, city_map):
    # Get valid neighbors from a starting tile
    x, y = pos
    neighbors = []
    for dx, dy in [(-1,0), (1,0), (0,-1), (0,1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < len(city_map) and 0 <= ny < len(city_map[0]):
            if city_map[nx][ny] is not None and city_map[nx][ny] != 'N': # Not OOB and not wall
                neighbors.append((nx, ny))
    return neighbors


# BASIC SEARCH ALGORITHMS

def bfs(city_map, start, goal):
    queue = deque([(start, [])])
    visited = set()

    while queue:
        current, path = queue.popleft()
        if current == goal:
            return path + [current]
        if current in visited:
            continue
        visited.add(current)
        for neighbor in get_neighbors(current, city_map):
            queue.append((neighbor, path + [current]))
    return None


def dfs(city_map, start, goal):
    stack = [(start, [])]
    visited = set()

    while stack:
        current, path = stack.pop()
        if current == goal:
            return path + [current]
        if current in visited:
            continue
        visited.add(current)
        for neighbor in get_neighbors(current, city_map):
            stack.append((neighbor, path + [current]))
    return None


def ucs(city_map, start, goal):
    pq = [(0.0, start, [])]
    visited = set()

    while pq:
        cost, current, path = heapq.heappop(pq)
        if current == goal:
            return path + [current]
        if current in visited:
            continue
        visited.add(current)
        for neighbor in get_neighbors(current, city_map):
            tile = city_map[neighbor[0]][neighbor[1]]
            if isinstance(tile, (int, float)):
                heapq.heappush(pq, (cost + tile, neighbor, path + [current]))
    return None


def a_star(city_map, start, goal):
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    pq = [(heuristic(start, goal), 0.0, start, [])]
    visited = set()

    while pq:
        f, g, current, path = heapq.heappop(pq)
        if current == goal:
            return path + [current]
        if current in visited:
            continue
        visited.add(current)
        for neighbor in get_neighbors(current, city_map):
            cost = city_map[neighbor[0]][neighbor[1]]
            if isinstance(cost, (int, float)):
                new_g = g + cost
                heapq.heappush(pq, (new_g + heuristic(neighbor, goal), new_g, neighbor, path + [current]))
    return None


# ADVANCED SEARCH ALGORITHMS

def iddfs(city_map, start, goal, max_depth=50):
    def dls(current, path, depth, visited):
        if current == goal:
            return path + [current]
        if depth == 0:
            return None
        visited.add(current)
        for neighbor in get_neighbors(current, city_map):
            if neighbor not in visited:
                result = dls(neighbor, path + [current], depth - 1, visited)
                if result:
                    return result
        return None

    for depth in range(max_depth + 1):
        visited = set()
        result = dls(start, [], depth, visited)
        if result:
            return result
    return None


def bidirectional_bfs(city_map, start, goal):
    if start == goal:
        return [start]

    forward_queue = deque([(start, [])])
    backward_queue = deque([(goal, [])])
    forward_visited = {start: []}
    backward_visited = {goal: []}

    while forward_queue and backward_queue:
        curr_f, path_f = forward_queue.popleft()
        for neighbor in get_neighbors(curr_f, city_map):
            if neighbor not in forward_visited:
                forward_visited[neighbor] = path_f + [curr_f]
                forward_queue.append((neighbor, path_f + [curr_f]))
                if neighbor in backward_visited:
                    return forward_visited[neighbor] + [neighbor] + backward_visited[neighbor][::-1]

        curr_b, path_b = backward_queue.popleft()
        for neighbor in get_neighbors(curr_b, city_map):
            if neighbor not in backward_visited:
                backward_visited[neighbor] = path_b + [curr_b]
                backward_queue.append((neighbor, path_b + [curr_b]))
                if neighbor in forward_visited:
                    return forward_visited[neighbor] + [neighbor] + backward_visited[neighbor][::-1]

    return None


def beam_search(city_map, start, goal, beam_width=2):
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])

    frontier = [(heuristic(start, goal), start, [])]
    visited = set()

    while frontier:
        frontier.sort()
        new_frontier = []

        for _, current, path in frontier[:beam_width]:
            if current == goal:
                return path + [current]
            if current in visited:
                continue
            visited.add(current)

            for neighbor in get_neighbors(current, city_map):
                if neighbor not in visited:
                    h = heuristic(neighbor, goal)
                    new_frontier.append((h, neighbor, path + [current]))
        frontier = new_frontier

    return None


def ida_star(city_map, start, goal, max_depth=1000):
    def heuristic(a, b):
        return abs(a[0] - b[0]) + abs(a[1] - b[1])  # Manhattan distance

    def search(path, g, threshold, visited):
        current = path[-1]
        f = g + heuristic(current, goal)
        if f > threshold:
            return f, None
        if current == goal:
            return f, path

        min_threshold = float('inf')
        for neighbor in get_neighbors(current, city_map):
            if neighbor in path:
                continue
            cost = city_map[neighbor[0]][neighbor[1]]
            if isinstance(cost, (int, float)):
                visited.add(neighbor)
                new_g = g + cost
                t, result_path = search(path + [neighbor], new_g, threshold, visited)
                if result_path:
                    return t, result_path
                if t < min_threshold:
                    min_threshold = t
        return min_threshold, None

    threshold = heuristic(start, goal)
    path = [start]
    visited = set([start])

    for _ in range(max_depth):
        t, result = search(path, 0.0, threshold, visited)
        if result:
            return result
        if t == float('inf'):
            return None
        threshold = t
    return None


def run_with_metrics(algorithm, city_map, start, goal, **kwargs):
    tracemalloc.start()
    start_time = time.time()

    visited_set = set()
    visited_order = []

    def wrapped_get_neighbors(pos, city_map):
        if pos not in visited_set:
            visited_set.add(pos)
            visited_order.append(pos)
        return get_neighbors_backup(pos, city_map)

    # Backup original get_neighbors
    global get_neighbors_backup
    get_neighbors_backup = get_neighbors
    globals()['get_neighbors'] = wrapped_get_neighbors

    try:
        path = algorithm(city_map, start, goal, **kwargs)
    finally:
        globals()['get_neighbors'] = get_neighbors_backup  # Restore original

    end_time = time.time()
    current_mem, peak_mem = tracemalloc.get_traced_memory()
    tracemalloc.stop()

    if path:
        cost = sum(city_map[x][y] for x, y in path if city_map[x][y] is not None)
        return {
            "path": path,
            "steps": len(path),
            "cost": cost,
            "nodes_explored": len(visited_order),
            "visited_order": visited_order,
            "time_seconds": end_time - start_time,
            "memory_bytes": peak_mem
        }
    else:
        return {
            "path": None,
            "steps": 0,
            "cost": 0.0,
            "nodes_explored": len(visited_order),
            "visited_order": visited_order,
            "time_seconds": end_time - start_time,
            "memory_bytes": peak_mem
        }
    
''' 
 ===== EXAMPLE USAGE =====
if __name__ == "__main__":
    # Generate a random map
    map_file = generate_random_map(width=10, height=10, wall_prob=0.2, num_goals=2)
    print(f"Generated map: {map_file}")

    # Parse the map
    city_map, starts, goals = parse_map(map_file)
    print("Parsed city map:")
    for row in city_map:
        print(row)

    # Run BFS on the first start and goal
    start = starts[0]
    goal = goals[0]
    print(f"Running BFS from {start} to {goal}...")
    result = run_with_metrics(bfs, city_map, start, goal)
    print("BFS Result:", result)

    # Clean up generated maps
    delete_map(all_maps=True)
    print("Deleted all generated maps.")
'''

